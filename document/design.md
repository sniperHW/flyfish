### 命令

客户端发送的请求

命令包含操作对象，参数，以及唯一序列号。每个命令有单独的response接口用于返回响应。

#### kv

kv的状态

		kv_invaild   = kvState(0)
		kv_new       = kvState(1)
		kv_loading   = kvState(2)
		kv_ok        = kvState(3)
		kv_no_record = kvState(4)

被load加载进内存，被kick踢出内存。

**kv加载进内存的流程**

* 接收到客户端对key的操作请求。

* 创建kv,标记为cache_new状态

* 发起异步任务，请求从数据库加载相关记录

* 数据库任务返回，请求raft模块发起proposal,将加载kv的操作同步到所有副本（无论记录在db中是否存在kv都会加载进内存，如果记录不存在kv被标记为cache_missing）。

* raft proposal提交，将kv状态设置为cache_ok或cache_missing。

**kv从内存中kick的流程**

* 接收到客户端发来的kick请求或触发lru kick

* 请求raft模块发起proposal,将kick操作同步到所有副本

* raft proposal提交，将状态设置为cache_remove，从字典中将kv移除

**限制**

只有完成了数据库回写的kv才会实际执行kick操作。

**从raft log恢复内存中的kv状态**

raft log记录了对kv操作的所有相关信息。进程启动后，加载raft log,并逐条执行以恢复内存状态。因此回写未完成的kv不会执行kick操作。否则将出现记录丢失的情况。（回写操作是异步执行的，如果提前执行了kick,而最终回写数据库的insert失败）



##### 异步任务

* 数据库加载任务
* raft proposal任务：

**proposal任务的优化**

如果对每个操作发起一次raft proposal，将使得各副本间频繁的执行raft通信，影响吞吐量。

因此,fly将请求推入队列，当队列满或到达设置的deadline时再将队列中的所有操作统一打包成一个raft proposal。只要设定合适的队列阀值和deadline即可在延迟和吞吐量之间找到合适的平衡点。



kv归kvnode管理，每kvnode一个处理队列，单线程处理请求，对kv的请求提交到kvnode处理队列处理。因此kv数据是线程安全的，无需锁保护。

sql回写处理

回写采用累积更新方式，及不针对每个操作产生一条回写请求。每个kv有一个单独的回写状态机，此状态机保存累积变更的状态。每当kvnode变更kv状态时，同时需要将变更状态更新到更新状态机。回写处理线程根据状态机中的状态产生回写请求。回写状态机涉及多线程处理，需要锁保护。

回写处理流程

kvnode线程

kvnode 设置kv的字段field1 field2

kvnode更新kv的回写状态机，用field1 field2的值覆盖状态机中的field1 field2值

kvnode检查kv当前是否已经设置回写处理标记，如果则设置标记通知发起回写处理请求。

回写线程

从队列取出kv的回写请求

根据kv的回写状态机生成回写操作（更新field1 field2），同时重置状态机中的变更（例如将fileds清空）。

执行回写操作。

执行完毕后，如果在此期间没有再发生kv变更，将回写处理标记清除。

如果在此期间在此发生变更，例如更新了field3，回写线程再次将kv投入到待处理队列尾部，再次处理（如果没有进一步的变更，则下次处理时将产生更新field3的回写操作）。



线程处理流程 内存不命中

网络线程 接收到客户端set请求

kvnode主线程 处理请求，kv不在内存中，请求load线程加载

load线程 加载kv完成后 根据set请求产生proposal,提交proposal

raft主线程 proposal accepted 通告kvnode主线程 apply

kvnode主线程 根据proposal设置内存中的kv，更新回写状态机，发起回写请求

回写线程 执行回写



线程处理流程 内存命中

网络线程 接收到客户端set请求

kvnode主线程 处理请求，根据set请求 提交proposal

raft主线程 proposal accepted 通告kvnode主线程apply

kvnode主线程 根据proposal设置内存中的kv，更新回写状态机，发起回写请求

回写线程 执行回写



raft快照

raft主线程 请求kvnode打快照 （阻塞操作，将阻塞raft线程）

kvnode线程 打快照，通过管道返回给raft线程

raft线程 raft协议处理快照

优化

raft主线程  publishEntries的时候判断是否需要打快照，如果需要发送给kvnode的apply里附带了需要打快照的标记（不阻塞）,并标记正在执行快照流程

kvnode主线程 打快照，将快照返回给raft主线程

raft主线程 开一个单独线程存储快照，完成后通知raft主线程

raft主线程 收到快照线程的完成通告，标记快照流程执行完毕



## 数据的删除与版本号

每条记录有一个64位版本号，当数据变更时将改变版本号。

记录删除有两种处理方法，一种是直接删除记录，另一种是仅仅标记删除。

对于方案1，如果采用初始版本号为，然后连续递增的方法将会产生问题。

例如：

A获取了记录a,此时版本号为2。

B删除记录a,之后再次插入记录a，此时版本号为1

C更新记录a,此时版本号为2。

A使用带版本的set更新a。因为此时版本确实为2，set成功。而此时的a实际上跟A本地的是不一致的，因此set不应该成功更新。

为了解决这个问题，记录的初始版本号不能使用1，而是使用`time.Now().UnixNano()`的值作为初始版本号。

这样只要不发生时间回退那么就肯定不会出现问题。

即使出现时间回退，问题发生的概率也低得可以忽略。



## DB回写

考虑一下场景

kv数据库从raft快照恢复了一个kv,此时要执行回写，应该用update还是insert语句。

1）使用insert语句，如果执行错误且错误是insert冲突则再次执行update语句

2）生成insert update语句。

3）按实际情况执行insert 或 update。

如果采用单条语句执行回写的做法，则方案1不适合。

方案2产生的语句要大一倍。

方案3比较复杂需要详细分析问题发生的情况。

场景1 记录a已经存在于数据库中

假如数据库回写操作严重延时

请求删除a,此时dbstate设置为delete

在次插入a,此时dbstate设置为insert

当数据库执行回写时将会发生insert冲突。

场景2 leader1失效，新的leader2产生，leader2获取lease后需要对本地数据执行一次回写。

此时对于`kv_ok`的记录应该执行insert还是update。

如果执行insert可能产生冲突，执行update，如果leader1在完成回写之前崩溃，数据库中将不存在记录，由此导致update失败。

## 数据库表格更新

新建表格

删除表格

新加字段

删除字段

变更字段

对于 删除表格 删除字段 变更字段 的情况，无法在不停止服务的情况下实现，（回写是异步的，例如在处理请求时，字段A还在，操作完成后向客户端返回操作成功，而在执行回写时，数据库已经将字段删除了，此时update失败）因此管理控制台将不提供功能，有需要的时候先停止服务，之后人工操作数据库。（完成后要清除所有的cache）

新建表格 新加字段

控制台操作成功后，通知kvnode获取新的表格配置信息。

对于新加表格的情况，如果在kvnode获取到最新配置前，业务方发起了对新表格的操作，将会因为找不到表格信息而拒绝。

对于新加字段的情况，如果在kvnode获取到最新配置前，业务方发起了对新加字段的操作，将会因为找不到对应字段而拒绝。





































