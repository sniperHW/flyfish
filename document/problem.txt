sql回写

flyfish采取sql异步回写，应保证flyfish内存数据与sql的最终一致性。

1）如果在leader执行sql回写前leader崩溃，将无法将数据回写sql。为了避免此问题，follower成为leader后需要对自己管理的所有kv发起一次
sql回写。


2）数据覆盖问题。

考虑如下场景,A是leader，执行sql回写前，因为网络分区，集群选举B为leader,此时A尚未感知到自己已经不是leader继续发出sql回写请求。
B此时也收到更新请求，执行回写。如果A回写在B之后执行，将导致老数据覆盖新数据。


解决方法:

使用lease,leader发出proposal申请租约，并定期续租，拥有lease才允许执行sql回写。如果lease失效丢弃所有回写操作。
这样A因为无法续约最终将无法执行sql回写。B等到A的租约失效后申请到租约后执行sql回写，即可保证回写有序。


lease

只有leader可以发起proposal,一旦proposal被commited,租约生效，leader需要定期续租，一旦发现失去leader权或租约过期，丢弃sql回写操作。

新的leader判断是否存在老的lease以及是否失效，如果已经失效发起proposal申请租约。租约需要保存到快照中。

租约使用固定的相对时间，所有节点在apply租约时，将失效时间设置为当前时间+租约时间。



3) 如前1所述，为了避免回写丢失，follower成为leader后需要对所有的kv发起一次sql回写。但此时leader可能尚未获得租约，因此回写无法执行。
此时kick操作不能执行，否则将导致数据丢失。因此需要增加一个kick锁，在follower成为leader之后将所有kv的kick锁锁住，以防止被执行kick。
当leader获得租约的时候释放kick锁，并发起回写请求（回写状态本身也会保护kv不会被kick）。



tbmeta

flykv在处理命令之前，检查字段是否符合tbmeta的定义，因此，在执行回写的时候，不会出现字段与db不符的情况。

例外

在执行命令的时候tbmeta与db的定义不一致，则会导致回写失败。

为了避免回写失败的情况。在整个系统尚未全部停止的情况下，禁止删除字段，改变字段的类型。只允许新增字段。

在整个系统已经停止，并确保所有kv都已经回写到db的情况下，允许对表做任何变更。但是如果做了表格删除，重命名，字段删除，字段重命名的以及字段类型变更的情况下，需要删除

所有flykv本地的raft日志和快照。


对于运行时需要增加表格和字段的情况，应先更新db，然后在更新tbmeta。













































