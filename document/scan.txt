scan返回整个表的行


表中的行由内存热数据以及db中的冷数据构成，每个kv对应db中的一行，创建时根据其key哈希计算出一个slot，这个slot将被保存到db中。

我们以slot为单位，获取行数据，请求发往store,由store负责构建slot相关的行数据并返回给客户端。

每个store管理着一系列slot。并且slot可能在store之间动态均衡。


1）依次遍历slot

我们可以从slot=0开始，依次查询slot在哪个store然后向store建立连接请求对应slot的行数据。

但是，slot是动态分配的不同store上的，连续的slot可能在不同的store上。如果slot的数量比较大，一次完成的遍历将要

向store请求建立slot数量的连接数（并非同时建立，依次建立）。


2）以store为单位遍历

我们也可以以store为单位遍历，首先选择一个store建立连接，请求它把由它管理的slot的所有行数据返回给客户端。

但是，因为slot是动态均衡的，这可能产生以下两个问题


1）slot的重复返回

slot:1在遍历store:1的时候已经返回，之后处理store:2,在此期间slot:1被迁移到store:3,处理store:3,slot:1被再次返回。

对此问题，客户端可以记录以及处理过的slot,请求发往store的时候把已经处理过的slot带上，store就可以忽略掉已经处理过的slot。


2）slot的遗漏

先处理store:1，接着处理store:2,在此期间store:3上的slot:3被迁移到store:1。处理store:3,slot:3丢失。

为了处理此问题，store遍历完毕后，client需要检查是否还有slot被遗漏，如有遗漏，再次请求遗漏的slot。


最优的处理办法应该是scan交给pd来处理，pd发现有scan任务尚未完毕的时候不触发迁移任务。

考虑到scan并不是flyfish推荐的常用操作，flyfish选择在scan发现slot遗漏的情况下直接将错误告知客户端。让客户端后续重试。





































