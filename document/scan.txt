遍历table

flyfish是一个热缓存，更新操作采用异步回写模式。因此，对数据库执行select all无法保证能返回所有的数据。

例如:

向flyfish发起一个set操作，因为key不存在，所以执行insert回写。
当set操作返回响应之后，立刻向db执行select不一定能返回刚insert的key,因为insert可能尚未执行。


为了能正确的处理因为回写延后执行导致select无法准确返回记录的情况。select返回的记录需要结合DB和flyfish的缓存内容。


首先，我们为每个key在数据库的记录添加一个__slot__字段，这个字段是根据key计算出来的，永远不会被改变。

其次，每个store管理固定的slot。

在执行遍历时，以store为单位，依次执行。

store生成select * from xxxx where __slot__ in (store管理的所有slot);

由此返回的记录就是与当前store相关的。

store结合缓存中的数据以及select返回的结果，生成一个记录集返回给客户端。


问题：

1）无法保证返回的结果集不重复。

例如：slot:1当前归store:1管理，store:1生成包含slot:1的结果集返回给客户端。

接着遍历store:2,正好在这个时候发生slot迁移，slot:1迁移到store:2。slot:1的结果集再一次返回给客户端。


2）同理，也无法完全保证结果集不丢失数据。


slot迁移只会发生在set的扩/缩容期间。因此在set的扩/缩容期间执行遍历可能无法得到正确的结果集。



为了完全避免以上问题，可以以slot为单位挨个slot遍历。



































