比对__version__回写


update task保存上一次成功执行回写后的__version__,暂时将其命名为last__version__

数据库判断last__version__是否与__version__字段一致，如果一致允许更新，数据库中的__version__字段也被更新为最新值。

update task将last__version__设置为最新__version__。


因为last__version__不在副本之间同步，因此，选出新leader之后，将last__version__设置为最新__version__值。

执行回写时，如果回写失败，则向数据库查询数据库中的__version__值，如果db.__version__ < kv.__version__,则将
last__version__设置为db.__version__,再次执行回写。否则，说明已经有别的更新的回写成功，本次回写直接丢弃。


delete的处理


考虑如下情况

leader1执行insert_update。将操作提交到db,操作因为网络原因延时。

leader1失去leadership,leader2当选，接收到delete操作，并成功执行回写。

leader1的请求被db接收到，此时之前的kv已经从数据库移除，insert_update操作成功插入之前已经被删除的记录。

解决方案，delete不删除，将记录__version__更新为无效值0。


之后被标记delete的的记录应该在某个合适的时间点被真正从数据库delete.

这个时间点就是记录被kick出flykv的时候。

对于kick操作，之后leader能执行，并且只有当回写操作执行完毕之后记录才能被kick。

对于标记删除的记录，使用kick_delete标记，生成delete操作。

如果操作成功执行则记录被kick掉。

现在考虑如下情况

leader1发出delete操作，之后失去leadership。

leader2当选，因为leader1没有完成kick,因此记录还在cache中。

1）Db收到leader1的delete操作，成功删除记录。

leader2接收到插入相同记录的操作请求，执行insert_update，因为记录已经被leader1删除，操作成功。

2）leader2接收到插入相同记录的操作请求，执行insert_update，记录尚未被leader1删除，操作成功，并将__version__更新为！=0.

db接收到leader1的delete操作，比对__version__发现!=0,操作失败。再次尝试时发现已经不是leader，放弃。


第二种情况

leader1当选，执行全量回写，对记录1产生insert_update。DB提交延时
leader1失去leadership,leader2当选，接到请求delete记录1，并且记录1被kick,此时DB中将不再存在记录1。
DB接收到leader1对记录1的insert_update，被删除的记录1再次被插入。

解决方案

如果kick的记录不是mark delete,则直接执行回写。

否则记录处于mark delete状态，则将记录放到gc队列中，将gc超时时间设置为一个比较长的时间，例如5分钟，以应付前任leader的回写延迟。

如果超时前记录复活，则将记录从gc队列移除。
超时之后执行delete回写成功后将记录移除。



2022-02-14更新

updater完成更新后,再次检查kv是否dirty,如果clean向raft log添加一条日志，标识kv clean。

新leader当选后，对所有dirty的kv执行一次强制回写。

1）clean状态的丢失

回写与添加raft日志不是原子操作，因此在updater完成sql回写之后，添加的clean日志没有触发（回写之后崩溃，或回写之后丢失leadership)。
此时在新leader上，这个已经完成回写的kv依然是dirty状态，因此新leader需要对这类kv生成一次强制回写。

2）对delete的处理，之前已经提到过，前任leader最后的回写可能会覆盖继任leader的回写。在添加clean日志后，情况如下。

leader1当选，执行全量回写，对记录1产生insert_update。DB提交延时

leader1失去leadership，因此clean标记无法触发。

leader2当选，接到请求delete记录1，





























































