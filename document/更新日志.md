2022-2-11更新

取消leader回写租约机制。

改为leader在apply第一个proposal_nop之后启动延时定时器，定时器触发后将获得回写权。

延时设定得稍微大一点，以保证失联leader最后的回写在新leader执行回写之前执行（flykv开启了CheckQuorum，失联leader最多一个ElectionTimeout就会发现自己
失去leadership,一旦发现失去leadership也就丧失回写权，后续回写直接被丢弃。延时主要是让失联leader最后已经发出的sql操作有足够的时间完成，让新leader发出的sql操作必定在失联leader最后的操作执行完之后才允许发出，更大的延时设定能保证这一点，但将导致新leader在这段时间内无法执行sql回写，这主要将影响kick机制，因为没有完成回写的kv是不允许被kick的）。


2022-2-15更新

回写使用__version__比对，完全避免旧的回写覆盖最新回写

delete不直接删除db中的记录，使用mark delete。

version的绝对值严格递增。

记录的每次变更(update/delete)都递增abs(version)。

被标记delete的记录verison < 0.


2022-2-17更新

kv增加lastWriteBackVersion字段，db回写完成后，将最新version提交proposal。
apply proposal时更新kv.lastWriteBackVersion

leader当选后不在需要对所有kv执行强制回写，只有kv.version != kv.lastWriteBackVersion的才执行强制回写。


2022-2-21更新

暂时取消指令合并

添加write_back_on_swap模式,kv变更后不立即触发回写，当kv被换出时才回写。

取消定时器执行lru替换，改为cache容量不足时再选择需要替换的kv。

2022-2-25更新

采取mark_delete后，kv的每次操作将导致abs(version)递增。

考虑如下情况：

insert kk version=1
update kk version=2
delete kk version=-3

执行回写，此时会执行mark_delete回写，但是因为kk在数据库中不存在，所以回写失败。

下次再次insert kk时version又从1开始

为了避免这种情况

如上描述的情况不能执行mark_delete回写，需要使用insert回写。使用字段的默认值以及最新的version执行insert。












